\section{Introduction}
\subsection{Context}\label{sec:context}
Data centres are becoming increasingly essential in the IT sector. Whether it is
Google's cloud platform, Microsoft Azure, or Amazon's web services, news about
new data centres seems like a daily occurrence. With such scale comes an
ever-growing need for custom solutions and cutting-edge technologies to both
reduce power consumption and improve overall performance.

Historically, solid-state drives (SSDs) served as drop-in replacements for
magnetic disks, utilizing similar interfaces to ensure seamless integration. But
the use of SSDs came with multiple improvements over the magnetic disks of the
past, which were hindered by said interface. As such, there was a rapid movement
towards Open-channel SSDs that do not have a firmware Flash Translation Layer
and instead leave the management of the physical SSD to the computer's operating
system. This solves the issue mentioned previously but introduces further data
transferring between the Central Processing Unit(CPU) and the SSD. However, in
recent years, the discrepancy between a storage device's READ and WRITE
operations and a CPU's ability to perform READ and WRITE memory operations has
been ever increasing. If this trend continues, the CPU will soon become a
bottleneck for performance in the data centers.

A solution to the problem would be to offload the CPU and provide computation at
the SSD level. Such a solution has been described as a computational storage
device (CSD). This would involve implementing the most commonly used data
manipulations, such as indexing into an SSD or more complex manipulations like
sorting. Within this thesis, the issue of implementing a high-performance
sorting algorithm running on a stand-alone bare metal processor has been
investigated.


\subsection{Problem}\label{sec:problem}
For computational storage to be a viable solution for meeting the ever-growing
demand for massive data computations, it is essential to investigate whether
implementing a processor designed for such a purpose is feasible. Consequently,
several open questions remain unanswered. (1) What type of computation should be
performed by a storage device? (2) Is it possible to implement such computation
on a bare-metal processor?

\begin{enumerate}
  \item {\large \textbf{What computation should be handled by a storage
    device?}}\label{sec:computational} \\
    Although there are multiple cases of large data transfers between a CPU and
    an SSD, one of the more prominent is that of sorting a given array. Sorting
    plays an integral part in multiple programming scenarios. From being an
    integral part of many searching algorithms to its use in data science, fast
    sorting is a necessity for fast performance. With a running time of O(n log
    n), merge sort was the algorithm chosen for further investigation. Moreover,
    parallel versions of the merge sort algorithm should be feasible on
    bare-metal\footnote{Bare metal is described further in
    Section~\ref{sec:bare-metal}.}.
  \item {\large \textbf{ Is it feasible to implement such a computation on a
    bare metal RISC-V processor?}} \\
    As the main goal is to offload the primary CPU, we must investigate whether
    it is at all possible to create a high-performance sorting algorithm on a
    bare-metal processor.
\end{enumerate}


\subsection{Approach}\label{sec:approach}
For this thesis, an experimental approach was taken. First, a feasible design
developed for implementing on a bare metal processor is introduced. Secondly, an
implementation of said designed is presented. Third, the viability and validity
of the implementation is evaluated. Lastly, shortcomings and proposed further
research are presented. These implementations will be carried out on a QEMU
virtual machine where the code is loaded via a general loader.

\subsection{Contribution}
For this thesis, the following contributions have been made:
\begin{enumerate}
  \item Present available design patterns when developing a computational
    storage device
  \item Designed and implement a specific merge sort algorithm meant for running of a
    bare-metal processor as described in Section~\ref{sec:bare-metal}.
  \item Evaluate the implementation on lists of varying sizes.
  \item Evaluate the viability of custom bare-metal applications for later use
    as a Computational Storage Device.
\end{enumerate}


\subsection{Related work}
Marcelino et al. \cite{sorting_units} evaluate three hardware sorting units
implemented with specific Field Programmable Gate Arrays (FPGAs). One of these
being the FIFO-based merge sorting machine, where they present a merge sorting
structure for a FIFO embedded system merging. This implementation assumes two
input lists of two sorted arrays and they later propose a hybrid solution using
Insertion and FIFO based merge sorting. With this they find that the FPGA hybrid
insertion and FIFO-based merge sorting sees speed-ups between 1.6 and 15 time
compared to a quick sort pure software solution.

Jackson et al. \cite{flash_sorting} look for faster sorting algorithms used for
flash memory embedded devices. They provide a merge sort for sorting with
minimal memory usage which aims to reduce the number of WRITES to flash memory.
This implementation would only need to memory buffers. They find that when
sorting large data sets with small memory the proposed algorithms reduces I/Os
and execution time by about 30\%.

Lobo et al. \cite{merge_sort} compare the performance of different types of
merge sort algorithms. Within their testing they find that the serial and
parallel merge sort discussed within this paper have a similar amount of resource
utilization, but find the delay of the parallel merge sort to be a lot smaller
than the serial counterpart. As such, they theorize that this implies the
parallel execution to be much faster than the serial.
