\section{Evaluation}

\subsection{Testing}
Testing has been accomplished by providing a random\_numbers.py file. With three
separate integer parameters, it creates a random list using Python's standard
random library. The inputs include a lower and upper bound for the list to
generate, together with the length of the list. Once the list is created,
running make will create a .elf file, which contains the parallel mergesort
algorithm with the unsorted list hardcoded within. Once the .elf file is loaded
on a RISC-V processor, it will immediately begin sorting the hardcoded list. The
implementation also needs the value NUM\_CORES defined within the Makefile, where
it both defines a constant NUM\_CORES for the .elf file to use, and the same
value is used for running the QEMU virtual machine.

This gives the following work flow for creating and running a test:
\begin{itemize}
  \item change directory to src/bare_metal
  \item Run random\_numbers.py to generate alist.c with an unsorted list.
  \item Change the NUM\_CORES variable in the Makefile to the desired number of
    cores.
  \item run "make clean" to remove all files built with previous settings.
  \item run "make test" to generate the .elf file and host qemu. This step will
    create a test.txt file, as the stdout of qemu is redirected to said file.
  \item run "python3 validate.py". This reads the test.txt file, which sorts the
    unsorted array with pythons built in sort function, and compares that sorted
    array with the one produced by the .elf file running in qemu.
\end{itemize}

\subsubsection*{Debugging}
\begin{figure}
  \centering
  \begin{subfigure}[b]{0.49\textwidth}
    \centering
    \includegraphics[width=\textwidth]{./figures/debug1.png}
    \caption{Connecting gdb-server}

  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.49\textwidth}
    \centering
    \includegraphics[width=\textwidth]{./figures/debug2.png}
    \caption{A break at mark\_done}
  \end{subfigure}
  \caption{Debugging the QEMU virtual machine}\label{fig:debug}
\end{figure}


To access and debug the multicore system, QEMU provides a way for a remote
gdb-server to connect at the start of execution.\cite{QEMU} In a system where
each core is equivalent gdb will automatically detect the cores, but will
display them as threads. This allows one to debug the QEMU virtual machine with
the same methodology used when debugging multithreaded execution. The workflow shown in Figure~\ref{fig:debug} is as follows:
\begin{itemize}
  \item Change directory to src/bare_metal.
  \item Initialize the alist.c file with an array and a given size.
  \item Run "make debug" to initialize the QEMU virtual machine.
  \item In a seperate terminal instance run "riscv32-unknown-elf-gdb". This will
    automatically run the commands in the ".gdbinit" file and connect to the
    QEMU virtual machine.
  \item Break at mark\_done. This function is run whenever a given thread job is
    finished.
  \item Run "info threads" to get an overview of all threads.
\end{itemize}





\subsection{Validation}\label{sec:validate}
\begin{table}
  \caption{Table of tests run}\label{tab:tests}
  \begin{center}
    \begin{tabular}[c]{l|l|l|l|l|l|l}
      & \multicolumn{6}{c}{NUM\_CORES}\\
      \cline{2-7}
      Lower:Upper:Number & 2 & 4 & 8 & 16 & 32 & 64\\
      \hline
      -100:0:100 & true & true & true & true & true & true \\
      \hline
      0:100:100 & true & true & true & true & true & true\\
      \hline
      -50:50:100 & true & true & true & true & true & true \\
      \hline
      -1000:1000:1000 & true* & true* & true* & true* & true* & **true
    \end{tabular} \\
    \vspace{1em}
    \raggedright{\footnotesize *This run initially failed due to stack overflow. After
    increasing the size of STACK\_SIZE to 8192 bytes, THREAD\_STACK\_SIZE to
  8192 and GLOBAL\_STACK\_SIZE 10MB bytes it worked.} \\
    \raggedright{\footnotesize **This run passed }
  \end{center}
\end{table}

When running a test, the ELF file first prints the unsorted array, and then once
sorting is done, it prints it again. When executing "make test", the QEMU
virtual machine outputs the stdout to a file called test.txt. Subsequently,
invoking python3 validate.py reads this file to ascertain if sorting was
performed correctly. In Table 6, an overview of some tests I conducted can be
seen. On the left, the formatting is specified as the lower bound of randomly
selected numbers, the upper bound, and the number of random elements in the
list. A value of true signifies that the validate.py file executed without
throwing an assertion error. The tests were initially performed with a global
stack of 0x800,\footnote{defined in ram.ld. Equates to 20,48 bytes.} a
STACK\_SIZE of 2048 and a THREAD\_STACK\_SIZE of 1024. If a failure occurred,
modifications were made to these three values in an attempt to pass the test.

\subsection{Future work}
The implementation proposed in this thesis is more a proof of concept, and as
such comes with a few shortcomings. First, as seen in Table~\ref{tab:tests},
when we both increase the number of cores and the size of the list to be
shorted, we run into memory issues. With the current method of creating thread
stacks, we allocate the same number bytes to each thread stack without taking
into account the amount of work each thread has to do. Whenever a thread has to
do a merge operation on a subsection of a list, it has to copy both sides into
seperate lists, before it can sort the array in place. This means, that a list
doing a merge on the entire lists, has to create a copy of the entire list.
Similairly a list, which has to only sort half the list, would in theory only
need half the amount of stack size (not taking into account other factors than
just the list copying).





